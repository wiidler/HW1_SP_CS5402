import pandas as pd
import ast
import numpy as np
import wfdb
from typing import Dict

"""PLEASE RENAME your solution TO FIRSTNAME_LASTNAME_solution.py"""

# Step-1, part 1
def parse_ptbxl_data()->pd.DataFrame:
    """
    Use pandas for this task.
    Implement this function to parse the ptbxl samples. It should
    return a dataframe with the filename_lr and diagnostic_class column.
    The filename_lr is the filename of the low-resolution ECG signal, and
    the diagnostic_class is generated by converting the scp_codes
    in the ptbxl database to diagnostic_class in the scp_statements database.
    There are 5 classes in total: [NORM, MI, STTC, CD, HYP].
    
    Since we want to simulate using the dataset to train a model, the class needs to have 
    at least one class, and any empty entries should be removed. 
    
    The end result should look like this:
    ecg_id filename_lr diagnostic_class
    1 records100/xxxxx/xxxxxx_lr  ['HYP']
    2 records100/xxxxx/xxxxxx_lr  ['MI']
    3 records100/xxxxx/xxxxxx_lr  ['MI, STTC']
    ...
    """
    #TODO: Implement this function
    
    #return result_df
    return


# Step-1, part 2
def create_dataset(df: pd.DataFrame) -> tuple[np.ndarray, np.ndarray]:
 
    """
    Use numpy and wfdb for this task.
    The data are located in /records100/, and you can read them like this:
    signal, _ = wfdb.rdsamp(filepath), where signal is a numpy array that
    should have shape [signal_length(1000), num_channels(12)].
    Implement this function to create a dataset from the dataframe df, which should be the output of 
    parse_ptbxl_data. 

    Convert the textual class labels into one-hot encoding. For example, using the label order [NORM, MI, STTC, CD, HYP],
    an ECG signal with labels [HYP, MI, STTC] would be converted to [0, 1, 1, 0, 1].

    Return two numpy arrays:
    - data_x: array should contain the ECG data with shape [num_samples, signal_length(1000), num_channels(12)].
    - data_y: array should contain the labels with shape   [num_samples, num_classes(5)].
    """
    #TODO: Implement this function

    # you can read the raw ECG signal with this function:
    # ECG_signal, _ = wfdb.rdsamp("filename_lr")

    # return data_x, data_y
    return

# Step-2:
def data_preprocessing(data_x: np.ndarray, data_y: np.ndarray) -> tuple[np.ndarray, np.ndarray]:
    """
    Perform data preprocessing: 
    - Check for missing values (or N/A), anomalies, and outliers. 
        - Fill missing values with the average of adjacent points in the same channel. 
        - Replace outliers using the 97th percentile (np.percentile(x, 97)). 
    - Normalize each channel with the equation: (x - xmin)/(xmax - xmin).
        - xmax: represents the maximum value of a channel
        - xmin: represents the minimum value of the channel.
    After normalization, the values will be scaled to range from 0 to 1.
    """

    #TODO: Implement this function.

    # return data_x_normalized, data_y_normalized
    return


# Step-3
def split_data(data_x: np.ndarray, data_y: np.ndarray) -> tuple[Dict[str, np.ndarray], Dict[str, np.ndarray], Dict[str, np.ndarray]]:
    """
    Implement this function to split the dataset into train, test, and validation sets at a 7:2:1 ratio.
    """
    #TODO: Implement this function
    
    # train_dataset = {"data_x": np.ndarray,
    #                  "data_y": np.ndarray}
    # val_dataset   = {"data_x": np.ndarray,
    #                  "data_y": np.ndarray}
    # test_dataset  = {"data_x": np.ndarray,
    #                  "data_y": np.ndarray}
    #return train_dataset, val_dataset, test_dataset.

    # return train_dataset, val_dataset, test_dataset
    return